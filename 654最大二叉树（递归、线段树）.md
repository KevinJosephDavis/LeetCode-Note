### 654最大二叉树：递归

题目链接：[654. 最大二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-binary-tree/description/)

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 *`nums` 构建的* **最大二叉树** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)

```
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`
- `nums` 中的所有整数 **互不相同**

使用递归是显然的。在每个子问题中，我们需要处理的事情很简单：找到数组在某个区间内的最大值，new一个节点并使其值为这个最大值。接下来就是要找到这个最大值左边数组的最大值和右边数组的最大值，分析到这里思路就很清晰了，这就是个重复的问题：在给定区间内找最大值罢了

递归函数：

```c++
    //找到[left,right)之间的最大值，构造根节点，递归
    TreeNode* f(vector<int>&nums,int left,int right) {
        //[left,right) 左闭右开 构造二叉树
        //先判终止条件
        if(left>=right) return nullptr;
        //找根节点下标，以便确定分界点
        int maxval_index=left;
        for(size_t i=left;i<right;i++) {
            if(nums[i]>nums[maxval_index]) {
                maxval_index=i;
            }
        }
        //构造根节点
        TreeNode* root=new TreeNode(nums[maxval_index]);

        //它的左子节点是它左侧数组的最大值，右同理
        root->left=f(nums,left,maxval_index);

        root->right=f(nums,maxval_index+1,right);

        return root;
    }
```

区间开闭无所谓

这里的终止条件实际上就帮我们处理了边界位置本身就是最大值的情况，`return nullptr`保证了它一侧必然没有子节点

这样我们就避免了对vector进行切割再构造

完整代码：

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //找到[left,right)之间的最大值，构造根节点，递归
    TreeNode* f(vector<int>&nums,int left,int right) {
        //[left,right) 左闭右开 构造二叉树
        //先判特殊情况
        if(left>=right) return nullptr;
        //找根节点下标，以便确定分界点
        int maxval_index=left;
        for(size_t i=left;i<right;i++) {
            if(nums[i]>nums[maxval_index]) {
                maxval_index=i;
            }
        }
        //构造根节点
        TreeNode* root=new TreeNode(nums[maxval_index]);

        //它的左子节点是它左边数字的最大值，右同理
        root->left=f(nums,left,maxval_index);

        root->right=f(nums,maxval_index+1,right);

        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return f(nums,0,nums.size());
    }
};
```



