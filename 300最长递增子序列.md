题目链接：[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

 

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

不考虑降低时间复杂度的话，此题还是相对简单的。

从一般情况考虑，欲求`dp[i]`（设`dp[i]`表示以`nums[i]`结尾的最长递增子序列长度），只需要找出`nums[i]`之前比其小的`nums[j]`，那么`dp[i]`就等于`dp[j]`+1.由于要求最大，所以在遍历的时候用max更新最大的即可。

递推公式已经出来了，接着考虑初始化。显然`dp[0]`=0，因为一个数字也可以构成一个子序列，正如示例三。

最后，也用max更新最大的`dp[i]`即可。

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int ans=0;
        int n=nums.size();
        if (n<=1) return n;
        vector<int>dp(n,1);
        for(int i=1;i<n;i++) {
            for(int j=0;j<i;j++) {
                if(nums[j]<nums[i]) {
                    dp[i]=max(dp[i],dp[j]+1);//这里不是比较，而是更新最大值
                }
            }
            ans=max(ans,dp[i]);//这里同理，也是在更新最大值
        }
        return ans;
    }
};
```

Go版本：

```go
func lengthOfLIS(nums []int) int {
    dp:=make([]int,len(nums))
    for i:= range dp {
        dp[i]=1
    }
    ans:=dp[0]
    for i:=1;i<len(nums);i++ {
        for j:=0;j<i;j++ {
            if nums[j]<nums[i] {
                dp[i]=max(dp[i],dp[j]+1)
            }
        }
        ans=max(ans,dp[i])
    }
    return ans
}
```

时间复杂度为O(N^2)，考虑进行优化。

优化的代码明天再研究了。